<!----------------------------------------------------------------------------
   FileSystem.cpp.htm  -Published HTML File
   Published on : 2017-04-04.21:42:52
   Author:Karthik Palepally Muniyappa  
----------------------------------------------------------------------------->
<html>
<head>
<link rel="stylesheet" href="../CSS/style.css">
</head>
<body>
<h3>FileSystem.cpp</h3>
<hr />
<div class="indent">
<h4>Dependencies:</h4>
<ul>
<li><a href="FileSystem.h.htm">FileSystem.h</a></li>
<li><a href="CppProperties.cpp.htm">CppProperties.cpp</a></li>
<li><a href="Utilities.h.htm">Utilities.h</a></li>
</ul>
</div>
<hr />
<pre>
///////////////////////////////////////////////////////////////////////////// 
// FileSystem.cpp - Support file and directory operations                  // 
// ver 2.6                                                                 // 
// ----------------------------------------------------------------------- // 
// copyright © Jim Fawcett, 2012                                           // 
// All rights granted provided that this notice is retained                // 
// ----------------------------------------------------------------------- // 
// Language:    Visual C++, Visual Studio 2010                             // 
// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      // 
// Application: Summer Projects, 2012                                      // 
// Author:      Jim Fawcett, CST 4-187, Syracuse University                // 
//              (315) 443-3948, jfawcett@twcny.rr.com                      // 
///////////////////////////////////////////////////////////////////////////// 
 
#include &lt;iostream&gt; 
#include &lt;string&gt; 
#include &lt;sstream&gt; 
#include &lt;iomanip&gt; 
#include &lt;utility&gt; 
#include &lt;clocale&gt; 
#include &lt;locale&gt; 
#include "FileSystem.h" 
 
using namespace FileSystem; 
 
///////////////////////////////////////////////////////// 
// helper FileSystemSearch 
 
class FileSystemSearch 
{<button onclick="myFunction(this)" id="button427">-</button><pre class="showElem" id="button427_pre"> 
public: 
  FileSystemSearch(); 
  ~FileSystemSearch(); 
  std::string firstFile(const std::string& path=".", const std::string& pattern="*.*"); 
  std::string nextFile(); 
  std::string firstDirectory(const std::string& path=".", const std::string& pattern="*.*"); 
  std::string nextDirectory(); 
  void close(); 
private: 
  HANDLE hFindFile; 
  WIN32_FIND_DATAA FindFileData; 
  WIN32_FIND_DATAA* pFindFileData; 
</pre>}; 
 
FileSystemSearch::FileSystemSearch() : pFindFileData(&FindFileData) {} 
FileSystemSearch::~FileSystemSearch() { ::FindClose(hFindFile); } 
void FileSystemSearch::close() { ::FindClose(hFindFile); } 
 
//----&lt; block constructor taking array iterators &gt;------------------------- 
 
Block::Block(Byte* beg, Byte* end) : bytes_(beg, end) {} 
 
//----&lt; push back block byte &gt;--------------------------------------------- 
 
void Block::push_back(Byte b) 
{<button onclick="myFunction(this)" id="button432">-</button><pre class="showElem" id="button432_pre"> 
  bytes_.push_back(b); 
</pre>} 
//----&lt; non-const indexer &gt;------------------------------------------------ 
 
Byte& Block::operator[](size_t i) 
{<button onclick="myFunction(this)" id="button433">-</button><pre class="showElem" id="button433_pre"> 
  if(i&lt;0 || bytes_.size() &lt;= i) 
    throw std::runtime_error("index out of range in Block"); 
  return bytes_[i]; 
</pre>} 
//----&lt; const indexer &gt;---------------------------------------------------- 
 
Byte Block::operator[](size_t i) const 
{<button onclick="myFunction(this)" id="button434">-</button><pre class="showElem" id="button434_pre"> 
  if(i&lt;0 || bytes_.size() &lt;= i) 
    throw std::runtime_error("index out of range in Block"); 
  return bytes_[i]; 
</pre>} 
//----&lt; equality comparison &gt;---------------------------------------------- 
 
bool Block::operator==(const Block& block) const 
{<button onclick="myFunction(this)" id="button435">-</button><pre class="showElem" id="button435_pre"> 
  return bytes_ == block.bytes_; 
</pre>} 
//----&lt; inequality comparison &gt;-------------------------------------------- 
 
bool Block::operator!=(const Block& block) const 
{<button onclick="myFunction(this)" id="button436">-</button><pre class="showElem" id="button436_pre"> 
  return bytes_ != block.bytes_; 
</pre>} 
//----&lt; return number of bytes in block &gt;---------------------------------- 
 
size_t Block::size() const 
{<button onclick="myFunction(this)" id="button437">-</button><pre class="showElem" id="button437_pre"> 
  return bytes_.size(); 
</pre>} 
 
//----&lt; File constructor opens file stream &gt;------------------------------- 
 
File::File(const std::string& filespec)  
    : name_(filespec), pIStream(nullptr), pOStream(nullptr), dirn_(in), typ_(text), good_(true) 
{ 
} 
//----&lt; File destructor closes file stream &gt;------------------------------- 
 
File::~File() <button onclick="myFunction(this)" id="button439">-</button><pre class="showElem" id="button439_pre"> 
{  
  if(pIStream) 
  { 
    pIStream-&gt;close();  
    delete pIStream; 
    pIStream = nullptr; 
    good_ = false; 
  } 
  if(pOStream) 
  { 
    pOStream-&gt;close(); 
    delete pOStream;  
    pOStream = nullptr; 
    good_ = false; 
  } 
</pre>} 
//----&lt; open for reading or writing &gt;-------------------------------------- 
 
bool File::open(direction dirn, type typ) 
{<button onclick="myFunction(this)" id="button440">-</button><pre class="showElem" id="button440_pre"> 
  dirn_ = dirn; 
  typ_ = typ; 
  good_ = true; 
  if(dirn == in) 
  { 
    pIStream = new std::ifstream; 
    if(typ == binary) 
      pIStream-&gt;open(name_.c_str(), std::ios::in | std::ios::binary); 
    else 
      pIStream-&gt;open(name_.c_str(), std::ios::in); 
    if (!(*pIStream).good()) 
    { 
      good_ = false; 
      pIStream = nullptr; 
      //throw std::runtime_error("\n  open for input failed in File constructor"); 
    } 
  } 
  else 
  { 
    pOStream = new std::ofstream; 
    if(typ == binary) 
      pOStream-&gt;open(name_.c_str(), std::ios::out | std::ios::binary); 
    else 
      pOStream-&gt;open(name_.c_str(), std::ios::out); 
    if (!(*pOStream).good()) 
    { 
      good_ = false; 
      pOStream = nullptr; 
      //throw std::runtime_error("\n  open for output failed in File constructor"); 
    } 
  } 
  return good_; 
</pre>} 
//----&lt; reads one line of a text file &gt;------------------------------------ 
 
std::string File::getLine(bool keepNewLines) 
{<button onclick="myFunction(this)" id="button441">-</button><pre class="showElem" id="button441_pre"> 
  if(pIStream == nullptr || !pIStream-&gt;good()) 
    throw std::runtime_error("input stream not open"); 
  if(typ_ == binary) 
    throw std::runtime_error("getting text line from binary file"); 
  if(dirn_ == out) 
    throw std::runtime_error("reading output file"); 
 
  std::string store; 
  while (true) 
  { 
    char ch = pIStream-&gt;get(); 
    if (!isGood()) 
      return store; 
    if (ch == '\n') 
    { 
      if (keepNewLines) 
        store += ch; 
      return store; 
    } 
    store += ch; 
  } 
</pre>} 
//----&lt; read all lines of text file into one string &gt;---------------------- 
 
std::string File::readAll(bool keepNewLines) 
{<button onclick="myFunction(this)" id="button442">-</button><pre class="showElem" id="button442_pre"> 
  std::string store; 
  while (true) 
  { 
    if (!isGood()) 
      return store; 
    store += getLine(keepNewLines); 
    std::locale loc; 
    if (store.size() &gt; 0 && !std::isspace(store[store.size() - 1], loc)) 
      store += ' '; 
  } 
  return store; 
</pre>} 
//----&lt; writes one line of a text to a file &gt;------------------------------ 
 
void File::putLine(const std::string& s, bool wantReturn) 
{<button onclick="myFunction(this)" id="button443">-</button><pre class="showElem" id="button443_pre"> 
  if(pOStream == nullptr || !pOStream-&gt;good()) 
    throw std::runtime_error("output stream not open"); 
  if(typ_ == binary) 
    throw std::runtime_error("writing text line to binary file"); 
  if(dirn_ == in) 
    throw std::runtime_error("writing input file"); 
  for(size_t i=0; i&lt;s.size(); ++i) 
    pOStream-&gt;put(s[i]); 
  if(wantReturn) 
    pOStream-&gt;put('\n'); 
  pOStream-&gt;flush(); 
</pre>} 
//----&lt; reads a block of bytes from binary file &gt;-------------------------- 
 
Block File::getBlock(size_t size) 
{<button onclick="myFunction(this)" id="button444">-</button><pre class="showElem" id="button444_pre"> 
  if(pIStream == nullptr || !pIStream-&gt;good()) 
    throw std::runtime_error("input stream not open"); 
  if(typ_ != binary) 
    throw std::runtime_error("reading binary from text file"); 
  if(dirn_ == out) 
    throw std::runtime_error("reading output file"); 
  Block blk; 
  if(pIStream) 
  { 
    for(size_t i=0; i&lt;size; ++i) 
    { 
      Byte b; 
      pIStream-&gt;get(b); 
      if(pIStream-&gt;good()) 
        blk.push_back(b); 
      else 
        break; 
    } 
  } 
  return blk; 
</pre>} 
//----&lt; writes a block of bytes to binary file &gt;--------------------------- 
 
void File::putBlock(const Block& blk) 
{<button onclick="myFunction(this)" id="button445">-</button><pre class="showElem" id="button445_pre"> 
  if(pOStream == nullptr || !pOStream-&gt;good()) 
    throw std::runtime_error("output stream not open"); 
  if(typ_ != binary) 
    throw std::runtime_error("writing binary to text file"); 
  if(dirn_ == in) 
    throw std::runtime_error("writing input file"); 
  if(!pOStream-&gt;good()) 
    return; 
  for(size_t i=0; i&lt;blk.size(); ++i) 
  { 
    pOStream-&gt;put(blk[i]); 
  } 
</pre>} 
//----&lt; read buffer of bytes from binary file &gt;---------------------------- 
 
size_t File::getBuffer(size_t bufLen, File::byte* buffer) 
{<button onclick="myFunction(this)" id="button446">-</button><pre class="showElem" id="button446_pre"> 
  if (pIStream == nullptr || !pIStream-&gt;good()) 
    throw std::runtime_error("input stream not open"); 
  if (typ_ != binary) 
    throw std::runtime_error("reading binary from text file"); 
  if (dirn_ == out) 
    throw std::runtime_error("reading output file"); 
  size_t count = 0; 
  while (pIStream-&gt;good()) 
  { 
    buffer[count++] = pIStream-&gt;get(); 
      if (count == bufLen) 
        break; 
  } 
  if (!pIStream-&gt;good())  // don't write EOF char 
    --count; 
  return count; 
</pre>} 
//----&lt; write buffer of bytes to binary file &gt;------------------------------- 
 
void File::putBuffer(size_t bufLen, File::byte* buffer) 
{<button onclick="myFunction(this)" id="button447">-</button><pre class="showElem" id="button447_pre"> 
  if (pOStream == nullptr || !pOStream-&gt;good()) 
    throw std::runtime_error("output stream not open"); 
  if (typ_ != binary) 
    throw std::runtime_error("writing binary to text file"); 
  if (dirn_ == in) 
    throw std::runtime_error("writing input file"); 
  if (!pOStream-&gt;good()) 
    return; 
  size_t count = 0; 
  while(pOStream-&gt;good()) 
  { 
    pOStream-&gt;put(buffer[count++]); 
    if (count == bufLen) 
      break; 
  } 
</pre>} 
//----&lt; tests for error free stream state &gt;-------------------------------- 
 
bool File::isGood() 
{<button onclick="myFunction(this)" id="button448">-</button><pre class="showElem" id="button448_pre"> 
  if(!good_) 
    return false; 
  if(pIStream != nullptr) 
    return (good_ = pIStream-&gt;good()); 
  if(pOStream != nullptr) 
    return (good_ = pOStream-&gt;good()); 
  return (good_ = false); 
</pre>} 
//----&lt; flushes output stream to its file &gt;-------------------------------- 
 
void File::flush() 
{<button onclick="myFunction(this)" id="button449">-</button><pre class="showElem" id="button449_pre"> 
  if(pOStream != nullptr && pOStream-&gt;good()) 
    pOStream-&gt;flush(); 
</pre>} 
//----&lt; clears error state enabling operations again &gt;--------------------- 
 
void File::clear() 
{<button onclick="myFunction(this)" id="button450">-</button><pre class="showElem" id="button450_pre"> 
  if(pIStream != nullptr) 
    pIStream-&gt;clear(); 
  if(pOStream != nullptr) 
    pOStream-&gt;clear(); 
</pre>} 
//----&lt; close file handle &gt;------------------------------------------------ 
 
void File::close() 
{<button onclick="myFunction(this)" id="button451">-</button><pre class="showElem" id="button451_pre"> 
  File::flush(); 
  if (pIStream != nullptr) 
  { 
    pIStream-&gt;close(); 
    pIStream = nullptr; 
    good_ = false; 
  } 
  if (pOStream) 
  { 
    pOStream-&gt;close(); 
    pOStream = nullptr; 
    good_ = false; 
  } 
</pre>} 
//----&lt; file exists &gt;-------------------------------------------------- 
 
bool File::exists(const std::string& file) 
{<button onclick="myFunction(this)" id="button452">-</button><pre class="showElem" id="button452_pre"> 
  return ::GetFileAttributesA(file.c_str()) != INVALID_FILE_ATTRIBUTES; 
</pre>} 
//----&lt; copy file &gt;---------------------------------------------------- 
 
bool File::copy(const std::string& src, const std::string& dst, bool failIfExists) 
{<button onclick="myFunction(this)" id="button453">-</button><pre class="showElem" id="button453_pre"> 
  return ::CopyFileA(src.c_str(), dst.c_str(), failIfExists) != 0; 
</pre>} 
//----&lt; remove file &gt;-------------------------------------------------- 
 
bool File::remove(const std::string& file) 
{<button onclick="myFunction(this)" id="button454">-</button><pre class="showElem" id="button454_pre"> 
  return ::DeleteFileA(file.c_str()) != 0; 
</pre>} 
//----&lt; constructor &gt;-------------------------------------------------- 
 
FileInfo::FileInfo(const std::string& fileSpec) 
{<button onclick="myFunction(this)" id="button455">-</button><pre class="showElem" id="button455_pre"> 
  HANDLE hFile = ::FindFirstFileA(fileSpec.c_str(), &data); 
  if(hFile == INVALID_HANDLE_VALUE) 
    good_ = false; 
  else 
    good_ = true; 
</pre>} 
//----&lt; is passed filespec valid? &gt;------------------------------------ 
 
bool FileInfo::good() 
{<button onclick="myFunction(this)" id="button456">-</button><pre class="showElem" id="button456_pre"> 
  return good_; 
</pre>} 
//----&lt; return file name &gt;--------------------------------------------- 
 
std::string FileInfo::name() const 
{<button onclick="myFunction(this)" id="button457">-</button><pre class="showElem" id="button457_pre"> 
  return Path::getName(data.cFileName); 
</pre>} 
//----&lt; conversion helper &gt;-------------------------------------------- 
 
std::string FileInfo::intToString(long i) 
{<button onclick="myFunction(this)" id="button458">-</button><pre class="showElem" id="button458_pre"> 
  std::ostringstream out; 
  out.fill('0'); 
  out &lt;&lt; std::setw(2) &lt;&lt; i; 
  return out.str(); 
</pre>} 
//----&lt; return file date &gt;--------------------------------------------- 
 
std::string FileInfo::date(dateFormat df) const 
{<button onclick="myFunction(this)" id="button459">-</button><pre class="showElem" id="button459_pre"> 
  std::string dateStr, timeStr; 
  FILETIME ft; 
  SYSTEMTIME st; 
  ::FileTimeToLocalFileTime(&data.ftLastWriteTime, &ft); 
  ::FileTimeToSystemTime(&ft, &st); 
  dateStr = intToString(st.wMonth) + '/' + intToString(st.wDay) + '/' + intToString(st.wYear); 
  timeStr = intToString(st.wHour) + ':' + intToString(st.wMinute) + ':' + intToString(st.wSecond); 
  if(df == dateformat) 
    return dateStr; 
  if(df == timeformat) 
    return timeStr; 
  return dateStr + " " + timeStr; 
</pre>} 
//----&lt; return file size &gt;--------------------------------------------- 
 
size_t FileInfo::size() const 
{<button onclick="myFunction(this)" id="button460">-</button><pre class="showElem" id="button460_pre"> 
  return (size_t)(data.nFileSizeLow + (data.nFileSizeHigh &lt;&lt; 8)); 
</pre>} 
//----&lt; is type archive? &gt;--------------------------------------------- 
 
bool FileInfo::isArchive() const 
{<button onclick="myFunction(this)" id="button461">-</button><pre class="showElem" id="button461_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0; 
</pre>} 
//----&lt; is type compressed? &gt;------------------------------------------ 
 
bool FileInfo::isCompressed() const 
{<button onclick="myFunction(this)" id="button462">-</button><pre class="showElem" id="button462_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0; 
</pre>} 
//----&lt; is type directory? &gt;------------------------------------------- 
 
bool FileInfo::isDirectory() const 
{<button onclick="myFunction(this)" id="button463">-</button><pre class="showElem" id="button463_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0; 
</pre>} 
//----&lt; is type encrypted? &gt;--------------------------------------------- 
 
bool FileInfo::isEncrypted() const 
{<button onclick="myFunction(this)" id="button464">-</button><pre class="showElem" id="button464_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0; 
</pre>} 
//----&lt; is type hiddent? &gt;--------------------------------------------- 
 
bool FileInfo::isHidden() const 
{<button onclick="myFunction(this)" id="button465">-</button><pre class="showElem" id="button465_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0; 
</pre>} 
//----&lt; is type normal? &gt;--------------------------------------------- 
 
bool FileInfo::isNormal() const 
{<button onclick="myFunction(this)" id="button466">-</button><pre class="showElem" id="button466_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0; 
</pre>} 
//----&lt; is type offline? &gt;--------------------------------------------- 
 
bool FileInfo::isOffLine() const 
{<button onclick="myFunction(this)" id="button467">-</button><pre class="showElem" id="button467_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0; 
</pre>} 
//----&lt; is type readonly? &gt;-------------------------------------------- 
 
bool FileInfo::isReadOnly() const 
{<button onclick="myFunction(this)" id="button468">-</button><pre class="showElem" id="button468_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0; 
</pre>} 
//----&lt; is type system? &gt;---------------------------------------------- 
 
bool FileInfo::isSystem() const 
{<button onclick="myFunction(this)" id="button469">-</button><pre class="showElem" id="button469_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ) != 0; 
</pre>} 
//----&lt; is type temporary? &gt;------------------------------------------- 
 
bool FileInfo::isTemporary() const 
{<button onclick="myFunction(this)" id="button470">-</button><pre class="showElem" id="button470_pre"> 
  return (data.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0; 
</pre>} 
//----&lt; compare names alphabetically &gt;--------------------------------- 
 
bool FileInfo::operator&lt;(const FileInfo& fi) const 
{<button onclick="myFunction(this)" id="button471">-</button><pre class="showElem" id="button471_pre"> 
  return strcmp(data.cFileName, fi.data.cFileName) == -1; 
</pre>} 
//----&lt; compare names alphabetically &gt;--------------------------------- 
 
bool FileInfo::operator==(const FileInfo& fi) const 
{<button onclick="myFunction(this)" id="button472">-</button><pre class="showElem" id="button472_pre"> 
  return strcmp(data.cFileName, fi.data.cFileName) == 0; 
</pre>} 
//----&lt; compare names alphabetically &gt;--------------------------------- 
 
bool FileInfo::operator&gt;(const FileInfo& fi) const 
{<button onclick="myFunction(this)" id="button473">-</button><pre class="showElem" id="button473_pre"> 
  return strcmp(data.cFileName, fi.data.cFileName) == 1; 
</pre>} 
//----&lt; compare file times &gt;------------------------------------------- 
 
bool FileInfo::earlier(const FileInfo& fi) const 
{<button onclick="myFunction(this)" id="button474">-</button><pre class="showElem" id="button474_pre"> 
  FILETIME ft1 = data.ftLastWriteTime; 
  FILETIME ft2 = fi.data.ftLastWriteTime; 
  return ::CompareFileTime(&ft1, &ft2) == -1; 
</pre>} 
//----&lt; compare file times &gt;------------------------------------------- 
 
bool FileInfo::later(const FileInfo& fi) const 
{<button onclick="myFunction(this)" id="button475">-</button><pre class="showElem" id="button475_pre"> 
  FILETIME ft1 = data.ftLastWriteTime; 
  FILETIME ft2 = fi.data.ftLastWriteTime; 
  return ::CompareFileTime(&ft1, &ft2) == 1; 
</pre>} 
//----&lt; smaller &gt;------------------------------------------------------ 
 
bool FileInfo::smaller(const FileInfo &fi) const 
{<button onclick="myFunction(this)" id="button476">-</button><pre class="showElem" id="button476_pre"> 
  return size() &lt; fi.size(); 
</pre>} 
//----&lt; larger &gt;------------------------------------------------------- 
 
bool FileInfo::larger(const FileInfo &fi) const 
{<button onclick="myFunction(this)" id="button477">-</button><pre class="showElem" id="button477_pre"> 
  return size() &gt; fi.size(); 
</pre>} 
//----&lt; convert string to lower case chars &gt;--------------------------- 
 
std::string Path::toLower(const std::string& src) 
{<button onclick="myFunction(this)" id="button478">-</button><pre class="showElem" id="button478_pre"> 
  std::string temp; 
  for(size_t i=0; i&lt;src.length(); ++i) 
    temp += tolower(src[i]); 
  return temp; 
</pre>} 
//----&lt; convert string to upper case chars &gt;--------------------------- 
 
   
std::string Path::toUpper(const std::string& src) 
{<button onclick="myFunction(this)" id="button479">-</button><pre class="showElem" id="button479_pre"> 
  std::string temp; 
  for(size_t i=0; i&lt;src.length(); ++i) 
    temp += toupper(src[i]); 
  return temp; 
</pre>} 
//----&lt; get path from fileSpec &gt;--------------------------------------- 
 
std::string Path::getName(const std::string &fileSpec, bool withExt) 
{<button onclick="myFunction(this)" id="button480">-</button><pre class="showElem" id="button480_pre"> 
  size_t pos = fileSpec.find_last_of("/"); 
  if(pos &gt;= fileSpec.length()) 
  { 
    pos = fileSpec.find_last_of("\\"); 
    if(pos &gt;= fileSpec.length()) 
    { 
      // no path prepended 
      if(withExt) 
        return fileSpec; 
      else 
      { 
        // remove ext 
        size_t pos = fileSpec.find("."); 
        if(pos &gt; fileSpec.size()) 
          return fileSpec; 
        return fileSpec.substr(0, pos-1); 
      } 
    } 
  } 
  if(withExt) 
    return fileSpec.substr(pos+1,fileSpec.length()-pos); 
  else 
  { 
    // remove ext 
    size_t pos2 = fileSpec.find(".", pos); 
    if(pos2 &gt; fileSpec.size()) 
      // no ext 
      return fileSpec.substr(pos+1); 
    return fileSpec.substr(pos+1, pos2-pos-1); 
  } 
</pre>} 
//----&lt; get extension from fileSpec &gt;---------------------------------- 
   
std::string Path::getExt(const std::string& fileSpec) 
{<button onclick="myFunction(this)" id="button481">-</button><pre class="showElem" id="button481_pre"> 
  size_t pos1 = fileSpec.find_last_of('/'); 
  size_t pos2 = fileSpec.find_last_of('\\'); 
  size_t pos = fileSpec.find_last_of('.'); 
  // handle ../ or ..\\ with no extension 
  if(pos1 &lt; fileSpec.length() || pos2 &lt; fileSpec.length()) 
  { 
    if(pos &lt; min(pos1, pos2)) 
      return std::string(""); 
  } 
  // only . is extension delimiter 
  if(0 &lt;= pos && pos &lt; fileSpec.length()) 
    return toLower(fileSpec.substr(pos+1,fileSpec.length()-pos)); 
  return std::string(""); 
</pre>} 
//----&lt; get path from fileSpec &gt;--------------------------------------- 
 
std::string Path::getPath(const std::string &fileSpec) 
{<button onclick="myFunction(this)" id="button482">-</button><pre class="showElem" id="button482_pre"> 
  size_t pos = fileSpec.find_last_of("/"); 
  if(pos &gt;= fileSpec.length()) 
    pos = fileSpec.find_last_of("\\"); 
  if(pos &gt;= fileSpec.length()) 
    return "."; 
  if(fileSpec.find(".",pos+1)) 
    return fileSpec.substr(0,pos+1); 
  return fileSpec; 
</pre>} 
//----&lt; get absoluth path from fileSpec &gt;------------------------------ 
 
std::string Path::getFullFileSpec(const std::string &fileSpec) 
{<button onclick="myFunction(this)" id="button483">-</button><pre class="showElem" id="button483_pre"> 
  const size_t BufSize = 256; 
  char buffer[BufSize]; 
  char filebuffer[BufSize];  // don't use but GetFullPathName will 
  char* name = filebuffer; 
  ::GetFullPathNameA(fileSpec.c_str(),BufSize, buffer, &name); 
  return std::string(buffer); 
</pre>} 
//----&lt; create file spec from path and name &gt;-------------------------- 
 
std::string Path::fileSpec(const std::string &path, const std::string &name) 
{<button onclick="myFunction(this)" id="button484">-</button><pre class="showElem" id="button484_pre"> 
  std::string fs; 
  size_t len = path.size(); 
  if(path[len-1] == '/' || path[len-1] == '\\') 
    fs = path + name; 
  else 
  { 
    if(path.find("/") &lt; path.size()) 
      fs = path + "/" + name; 
    else if(path.find("\\") &lt; path.size()) 
      fs = path + "\\" + name; 
    else 
      fs = path + "/" + name; 
  } 
  return fs; 
</pre>} 
//----&lt; return name of the current directory &gt;----------------------------- 
 
std::string Directory::getCurrentDirectory() 
{<button onclick="myFunction(this)" id="button485">-</button><pre class="showElem" id="button485_pre"> 
  char buffer[MAX_PATH]; 
  ::GetCurrentDirectoryA(MAX_PATH,buffer); 
  return std::string(buffer); 
</pre>} 
//----&lt; change the current directory to path &gt;----------------------------- 
 
bool Directory::setCurrentDirectory(const std::string& path) 
{<button onclick="myFunction(this)" id="button486">-</button><pre class="showElem" id="button486_pre"> 
  return ::SetCurrentDirectoryA(path.c_str()) != 0; 
</pre>} 
//----&lt; get names of all the files matching pattern (path:name) &gt;---------- 
 
std::vector&lt;std::string&gt; Directory::getFiles(const std::string& path, const std::string& pattern) 
{<button onclick="myFunction(this)" id="button487">-</button><pre class="showElem" id="button487_pre"> 
  std::vector&lt;std::string&gt; files; 
  FileSystemSearch fss; 
  std::string file = fss.firstFile(path, pattern); 
  if(file.size() == 0) 
    return files; 
  files.push_back(file); 
  while(true) 
  { 
    file = fss.nextFile(); 
    if(file.size() == 0) 
      return files; 
    files.push_back(file); 
  } 
  return files; 
</pre>} 
//----&lt; get names of all directories matching pattern (path:name) &gt;-------- 
 
std::vector&lt;std::string&gt; Directory::getDirectories(const std::string& path, const std::string& pattern) 
{<button onclick="myFunction(this)" id="button488">-</button><pre class="showElem" id="button488_pre"> 
  std::vector&lt;std::string&gt; dirs; 
  FileSystemSearch fss; 
  std::string dir = fss.firstDirectory(path, pattern); 
  if(dir.size() == 0) 
    return dirs; 
  dirs.push_back(dir); 
  while(true) 
  { 
    dir = fss.nextDirectory(); 
    if(dir.size() == 0) 
      return dirs; 
    dirs.push_back(dir); 
  } 
  return dirs; 
</pre>} 
//----&lt; create directory &gt;------------------------------------------------- 
 
bool Directory::create(const std::string& path) 
{<button onclick="myFunction(this)" id="button489">-</button><pre class="showElem" id="button489_pre"> 
  return ::CreateDirectoryA(path.c_str(), NULL) == 0; 
</pre>} 
//----&lt; does directory exist? &gt;-------------------------------------------- 
 
bool Directory::exists(const std::string& path) 
{<button onclick="myFunction(this)" id="button490">-</button><pre class="showElem" id="button490_pre"> 
  DWORD dwAttrib = GetFileAttributesA(path.c_str()); 
 
  return (dwAttrib != INVALID_FILE_ATTRIBUTES &&  
         (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)); 
</pre>} 
//----&lt; remove directory &gt;------------------------------------------------- 
 
bool Directory::remove(const std::string& path) 
{<button onclick="myFunction(this)" id="button491">-</button><pre class="showElem" id="button491_pre"> 
  return ::RemoveDirectoryA(path.c_str()) == 0; 
</pre>} 
//----&lt; find first file &gt;-------------------------------------------------- 
 
std::string FileSystemSearch::firstFile(const std::string& path, const std::string& pattern) 
{<button onclick="myFunction(this)" id="button492">-</button><pre class="showElem" id="button492_pre"> 
  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData); 
  if(hFindFile != INVALID_HANDLE_VALUE) 
  { 
    if(!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
      return pFindFileData-&gt;cFileName; 
    else 
      while(::FindNextFileA(hFindFile, pFindFileData)) 
        if(!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
          return pFindFileData-&gt;cFileName; 
  } 
  return ""; 
</pre>} 
//----&lt; find next file &gt;--------------------------------------------------- 
 
std::string FileSystemSearch::nextFile() 
{<button onclick="myFunction(this)" id="button493">-</button><pre class="showElem" id="button493_pre"> 
  while(::FindNextFileA(hFindFile, pFindFileData)) 
    if(!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
      return pFindFileData-&gt;cFileName; 
  return ""; 
</pre>} 
//----&lt; find first file &gt;-------------------------------------------------- 
 
std::string FileSystemSearch::firstDirectory(const std::string& path, const std::string& pattern) 
{<button onclick="myFunction(this)" id="button494">-</button><pre class="showElem" id="button494_pre"> 
  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData); 
  if(hFindFile != INVALID_HANDLE_VALUE) 
  { 
    if(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
      return pFindFileData-&gt;cFileName; 
    else 
      while(::FindNextFileA(hFindFile, pFindFileData)) 
        if(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
          return pFindFileData-&gt;cFileName; 
  } 
  return ""; 
</pre>} 
//----&lt; find next file &gt;--------------------------------------------------- 
 
std::string FileSystemSearch::nextDirectory() 
{<button onclick="myFunction(this)" id="button495">-</button><pre class="showElem" id="button495_pre"> 
  while(::FindNextFileA(hFindFile, pFindFileData)) 
    if(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
      return pFindFileData-&gt;cFileName; 
  return ""; 
</pre>} 
//----&lt; test stub &gt;-------------------------------------------------------- 
 
#ifdef TEST_FILESYSTEM 
 
void title(const std::string& title, char ch='=') 
{<button onclick="myFunction(this)" id="button496">-</button><pre class="showElem" id="button496_pre"> 
  std::cout &lt;&lt; "\n  " &lt;&lt; title; 
  std::cout &lt;&lt; "\n " &lt;&lt; std::string(title.size()+2, ch); 
</pre>} 
int main(int argc, char* argv[]) 
{<button onclick="myFunction(this)" id="button497">-</button><pre class="showElem" id="button497_pre"> 
  title("Demonstrate Path Class"); 
 
  std::string fs = Path::fileSpec(".","temp.txt"); 
  std::cout &lt;&lt; "\n  Path::fileSpec(\".\",\"temp.txt\") = " &lt;&lt; fs; 
 
  std::string path = Path::getPath(fs); 
  std::cout &lt;&lt; "\n  Path::getPath(\"" + fs + "\") = " &lt;&lt; path; 
   
  std::string ffs = Path::getFullFileSpec(fs); 
  std::cout &lt;&lt; "\n  Path::getFullFileSpec(\"" + fs + "\") = " &lt;&lt; ffs; 
   
  std::string name = Path::getName(fs); 
  std::cout &lt;&lt; "\n  Path::getName(\"" + fs + "\") = " &lt;&lt; name; 
 
  std::string ext = Path::getExt(fs); 
  std::cout &lt;&lt; "\n  Path::getExt(\"" + fs + "\") = " &lt;&lt; ext; 
 
  std::string upper = Path::toUpper("temp.txt"); 
  std::cout &lt;&lt; "\n  Path::toUpper(\"temp.txt\") = " &lt;&lt; upper; 
 
  std::string lower = Path::toLower("Temp.Txt"); 
  std::cout &lt;&lt; "\n  Path::toLower(\"Temp.Txt\") = " &lt;&lt; lower; 
  std::cout &lt;&lt; std::endl; 
  /* 
  title("Demonstrate FileSystemSearch class"); 
 
  const size_t PathSetSize = 2; 
  std::string home = ::getenv("HOMEDRIVE"); 
  std::string pathSet[] = { home+"\\\\", "." }; 
  FileSystemSearch fss; 
  for(size_t i = 0; i&lt;PathSetSize; ++i) 
  { 
    std::cout &lt;&lt; "\n  searching for files on \"" &lt;&lt; pathSet[i] &lt;&lt; "\""; 
    std::cout &lt;&lt; "\n " &lt;&lt; std::string(27 + pathSet[i].size(), '-'); 
    std::string searchPath = pathSet[i]; 
    std::string fileName = fss.firstFile(searchPath); 
    if(fileName.size() &gt; 0) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fileName; 
    else 
      std::cout &lt;&lt; "\n  no files match search"; 
    while(true) { 
      fileName = fss.nextFile(); 
      if(fileName.size() &gt; 0) 
        std::cout &lt;&lt; "\n  " &lt;&lt; fileName; 
      else 
        break; 
    } 
    std::cout &lt;&lt; std::endl; 
 
    std::cout &lt;&lt; "\n  searching for directories on \"" &lt;&lt; pathSet[i] &lt;&lt; "\""; 
    std::cout &lt;&lt; "\n " &lt;&lt; std::string(33 + pathSet[i].size(), '-'); 
    std::string dirName = fss.firstDirectory(searchPath); 
    if(dirName.size() &gt; 0) 
      std::cout &lt;&lt; "\n  " &lt;&lt; dirName; 
    else 
      std::cout &lt;&lt; "\n  no directories match search"; 
    while(true) 
    { 
      dirName = fss.nextDirectory(); 
      if(dirName.size() &gt; 0) 
        std::cout &lt;&lt; "\n  " &lt;&lt; dirName; 
      else 
        break; 
    } 
    std::cout &lt;&lt; std::endl; 
  } 
  */ 
  title("Demonstrate Directory class"); 
 
  // Display contents of current directory 
 
  std::cout &lt;&lt; "\n  current directory is:\n    " &lt;&lt; Directory::getCurrentDirectory(); 
  std::cout &lt;&lt; "\n  It contains files:"; 
  std::vector&lt;std::string&gt; currfiles = Directory::getFiles(); 
  /////////////////////////////////////////////////////// 
  // This works too 
  // std::vector&lt;std::string&gt; currfiles = d.getFiles();   
  for(size_t i=0; i&lt;currfiles.size(); ++i) 
    std::cout &lt;&lt; "\n    " &lt;&lt; currfiles[i].c_str(); 
  std::cout &lt;&lt; "\n  and contains directories:"; 
  std::vector&lt;std::string&gt; currdirs = Directory::getDirectories(); 
  for(size_t i=0; i&lt;currdirs.size(); ++i) 
    std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str(); 
  std::cout &lt;&lt; "\n"; 
 
  // Display contents of non-current directory 
 
  std::cout &lt;&lt; "\n  .txt files residing in C:/temp are:"; 
  currfiles = Directory::getFiles("c:/temp/", "*.txt"); 
 
  // if we want fully qualified file names, we have to 
  // set the current directory to the path on which the files 
  // reside, if it isn't already so set 
 
  std::string currDir = Directory::getCurrentDirectory(); 
  Directory::setCurrentDirectory("c:/temp/"); 
  for(size_t i=0; i&lt;currfiles.size(); ++i) 
    std::cout &lt;&lt; "\n    " &lt;&lt; Path::getFullFileSpec(currfiles[i]).c_str(); 
  Directory::setCurrentDirectory(currDir); 
 
  // we have to restore the current directory so the 
  // remaining tests work 
 
  // it's probably easier just to use Path::fileSpec(path, filename) 
  // like this: 
 
  for (size_t i = 0; i&lt;currfiles.size(); ++i) 
    std::cout &lt;&lt; "\n    " &lt;&lt; Path::fileSpec("c:\\temp\\", currfiles[i]).c_str(); 
 
  std::cout &lt;&lt; "\n"; 
  std::cout &lt;&lt; "\n  directories residing in C:/temp are:"; 
  currdirs = Directory::getDirectories("c:/temp/"); 
  for(size_t i=0; i&lt;currdirs.size(); ++i) 
    std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str(); 
  std::cout &lt;&lt; "\n"; 
 
  // Create directory 
 
  title("Demonstrate FileInfo Class Operations", '='); 
  std::cout &lt;&lt; "\n"; 
 
  Directory::setCurrentDirectory("."); 
  std::cout &lt;&lt; "\n  current path is \"" &lt;&lt; Directory::getCurrentDirectory(); 
   
  std::string fn1; 
  if(argc &gt; 1) 
    fn1 = argv[1]; 
  else 
    fn1 = "c:\\temp\\test.txt"; 
  FileInfo fi(fn1); 
 
  if(fi.good()) 
  { 
    std::cout &lt;&lt; "\n  name: " &lt;&lt; "\t" &lt;&lt; fi.name(); 
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(); 
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::dateformat); 
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::timeformat); 
    std::cout &lt;&lt; "\n  size: " &lt;&lt; "\t" &lt;&lt; fi.size() &lt;&lt; " bytes"; 
    if(fi.isArchive()) 
      std::cout &lt;&lt; "\n  is archive"; 
    else 
      std::cout &lt;&lt; "\n  is not archive"; 
    if(fi.isCompressed()) 
      std::cout &lt;&lt; "\n  is compressed"; 
    else 
      std::cout &lt;&lt; "\n  is not compressed"; 
    if(fi.isDirectory()) 
      std::cout &lt;&lt; "\n  is directory"; 
    else 
      std::cout &lt;&lt; "\n  is not directory"; 
    if(fi.isEncrypted()) 
      std::cout &lt;&lt; "\n  is encrypted"; 
    else 
      std::cout &lt;&lt; "\n  is not encrypted"; 
    if(fi.isHidden()) 
      std::cout &lt;&lt; "\n  is hidden"; 
    else 
      std::cout &lt;&lt; "\n  is not hidden"; 
    if(fi.isNormal()) 
      std::cout &lt;&lt; "\n  is normal"; 
    else 
      std::cout &lt;&lt; "\n  is not normal"; 
    if(fi.isOffLine()) 
      std::cout &lt;&lt; "\n  is offline"; 
    else 
      std::cout &lt;&lt; "\n  is not offline"; 
    if(fi.isReadOnly()) 
      std::cout &lt;&lt; "\n  is readonly"; 
    else 
      std::cout &lt;&lt; "\n  is not readonly"; 
    if(fi.isSystem()) 
      std::cout &lt;&lt; "\n  is system"; 
    else 
      std::cout &lt;&lt; "\n  is not system"; 
    if(fi.isTemporary()) 
      std::cout &lt;&lt; "\n  is temporary"; 
    else 
      std::cout &lt;&lt; "\n  is not temporary"; 
  } 
  else 
    std::cout &lt;&lt; "\n  filename " &lt;&lt; fn1 &lt;&lt; " is not valid in this context\n"; 
 
  std::string fn2; 
  if(argc &gt; 2) 
  { 
    fn1 = argv[1]; 
    fn2 = argv[2]; 
  } 
  else 
  { 
    fn1 = "FileSystem.h"; 
    fn2 = "FileSystem.cpp"; 
  } 
  FileInfo fi1(fn1); 
  FileInfo fi2(fn2); 
  if(fi1.good() && fi2.good()) 
  { 
    if(fi1 == fi1) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi1.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi1.name(); 
    if(fi1 &lt; fi1) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi1.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &gt;= " &lt;&lt; fi1.name(); 
    if(fi1 == fi2) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi2.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi2.name(); 
    if(fi1 &lt; fi2) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi2.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &gt;= " &lt;&lt; fi2.name(); 
    if(fi1.smaller(fi2)) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is smaller than " &lt;&lt; fi2.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not smaller than " &lt;&lt; fi2.name(); 
    if(fi1.earlier(fi2)) 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is earlier than " &lt;&lt; fi2.name(); 
    else 
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not earlier than " &lt;&lt; fi2.name(); 
    std::cout &lt;&lt; std::endl; 
  } 
  else 
    std::cout &lt;&lt; "\n  files " &lt;&lt; fn1 &lt;&lt; " and " &lt;&lt; fn2 &lt;&lt; " are not valid in this context\n"; 
 
  title("Demonstrate File class operations", '='); 
  std::cout &lt;&lt; "\n"; 
 
  // copy binary file from one directory to another 
 
  File me("../debug/filesystemdemo.exe"); 
  me.open(File::in, File::binary); 
  std::cout &lt;&lt; "\n  copying " &lt;&lt; me.name().c_str() &lt;&lt; " to c:/temp"; 
  if(!me.isGood()) 
  { 
    std::cout &lt;&lt; "\n  can't open executable\n"; 
    std::cout &lt;&lt; "\n  looking for:\n  "; 
    std::cout &lt;&lt; Path::getFullFileSpec(me.name()) &lt;&lt; "\n"; 
  } 
  else 
  { 
    File you("c:/temp/fileSystemdemo.exe"); 
    you.open(File::out, File::binary); 
    if(you.isGood()) 
    { 
      while(me.isGood()) 
      { 
        static size_t count = 0; 
        Block b = me.getBlock(1024); 
        you.putBlock(b); 
        if (++count &lt; 10) 
        { 
          std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes"; 
          std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes"; 
        } 
        if (b.size() &lt; 1024) 
        { 
          std::cout &lt;&lt; "\n\n    omitted " &lt;&lt; count-10 &lt;&lt; " blocks from display\n\n"; 
          std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes"; 
          std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes"; 
        } 
      } 
      std::cout &lt;&lt; "\n"; 
    } 
  } 
 
  // save some filespecs of text files in a vector for File demonstrations 
 
  std::vector&lt;std::string&gt; files; 
  if(argc == 1) 
  { 
    std::cout &lt;&lt; "\n\n  Enter, on the command line, an additional filename to process.\n"; 
  } 
 
  for(int i=1; i&lt;argc; ++i) 
  { 
    files.push_back(argv[i]); 
  } 
  files.push_back("FileSystem.cpp");                     // file not on current path 
  files.push_back("../FileSystemDemo/FileSystem.cpp");   // file from project directory 
  files.push_back("../FileSystemTest.txt");              // file in solution directory 
  files.push_back("foobar");                             // doesn't exist 
 
  // open each file and display a few lines of text 
 
  for(size_t i=0; i&lt;files.size(); ++i) 
  { 
    File file(files[i]); 
    file.open(File::in); 
    if(!file.isGood()) 
    { 
      std::cout &lt;&lt; "\n  Can't open file " &lt;&lt; file.name(); 
      std::cout &lt;&lt; "\n  Here's what the program can't find:\n  " &lt;&lt; Path::getFullFileSpec(file.name());  
      continue; 
    } 
    std::string temp = std::string("Processing file ") + files[i]; 
    title(temp, '-'); 
    for(int j=0; j&lt;10; ++j) 
    { 
      if(!file.isGood()) 
        break; 
      std::cout &lt;&lt; "\n  -- " &lt;&lt; file.getLine().c_str(); 
    } 
    std::cout &lt;&lt; "\n"; 
  } 
  std::cout &lt;&lt; "\n"; 
 
  // read all lines of text file into string 
 
  title("testing File::readAll()", '-'); 
  std::cout &lt;&lt; "\n"; 
  File testAll("../FileSystemTest.txt"); 
  testAll.open(File::in); 
  if (testAll.isGood()) 
  { 
    std::string all = testAll.readAll(); 
    std::cout &lt;&lt; all &lt;&lt; "\n"; 
  } 
  testAll.close(); 
 
  title("testing File::readAll(true)", '-'); 
  std::cout &lt;&lt; "\n"; 
  File testAllTrue("../FileSystemTest.txt"); 
  testAllTrue.open(File::in); 
  if (testAllTrue.isGood()) 
  { 
    std::string all = testAllTrue.readAll(true); 
    std::cout &lt;&lt; all &lt;&lt; "\n"; 
  } 
  testAllTrue.close(); 
 
  // test reading non-text files 
 
  title("test reading non-text files", '-'); 
  std::cout &lt;&lt; "\n"; 
  std::string testPath = "./debug";  // run from project directory (what Visual Studio does) 
  if (!Directory::exists(testPath)) 
    testPath = ".";                  // run from solution debug directory 
  std::vector&lt;std::string&gt; testFiles = Directory::getFiles(testPath); 
  for (auto file : testFiles) 
  { 
    try 
    { 
      std::string ext = Path::getExt(file); 
      if (ext == "exe" || ext == "dll" || file == "run.dat") 
      { 
        /* reading binary file works, but generates a lot of garbage */ 
        /* I use run.dat to capture this output so including will make output confusing */ 
 
        std::cout &lt;&lt; "  skipping binary file " &lt;&lt; file &lt;&lt; "\n"; 
        continue; 
      } 
      File test(file); 
      test.open(File::in);  // open as text file 
      std::cout &lt;&lt; "\n  processing \"" &lt;&lt; file &lt;&lt; "\"\n"; 
      if (test.isGood()) 
      { 
        std::string text = test.readAll(true); 
        std::cout &lt;&lt; text &lt;&lt; "\n"; 
      } 
      else 
      { 
        std::cout &lt;&lt; "\n  open failed\n"; 
      } 
    } 
    catch (std::exception& ex) 
    { 
      std::cout &lt;&lt; "\n  Exception: " &lt;&lt; ex.what() &lt;&lt; "\n"; 
    } 
  } 
 
  // read text file and write to another text file 
 
  title("writing to c:/temp/test.txt", '-'); 
  File in("../FileSystemDemo/FileSystem.h"); 
  in.open(File::in, File::text); 
  File out("c:/temp/test.txt"); 
  out.open(File::out, File::text); 
  while(in.isGood()) 
  { 
    std::string temp = in.getLine(); 
    //std::cout &lt;&lt; "\n  " &lt;&lt; temp.c_str(); 
    out.putLine(temp); 
    out.putLine("\n"); 
  } 
  std::cout &lt;&lt; "\n  check c:/temp/test.txt to validate"; 
  std::cout &lt;&lt; "\n\n"; 
 
  // read and write buffers 
 
  title("reading and writing buffers"); 
  std::cout &lt;&lt; "\n  " &lt;&lt; FileSystem::Directory::getCurrentDirectory(); 
  std::string fileIn = "TestFileSystem/UnitTest.h"; 
  std::string fileOut = "TestFileSystem/CopyOfUnitTest.h"; 
  File bufferIn(fileIn); 
  bufferIn.open(File::in, File::binary); 
  if (!bufferIn.isGood()) 
  { 
    std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileIn &lt;&lt; "\" for reading"; 
      return 1; 
  } 
  else 
  { 
    std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileIn &lt;&lt; "\" for reading"; 
  } 
  File bufferOut(fileOut); 
  bufferOut.open(File::out, File::binary); 
  if (!bufferOut.isGood()) 
  { 
    std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileOut &lt;&lt; "\" for writing\n\n"; 
      return 1; 
  } 
  else 
  { 
    std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileOut &lt;&lt; "\" for writing"; 
  } 
  std::cout &lt;&lt; "\n"; 
  const size_t bufLen = 124; 
  File::byte buffer[bufLen]; 
  while (true) 
  { 
    size_t resultSize = bufferIn.getBuffer(bufLen, buffer); 
    //std::cout &lt;&lt; "\n  reading buffer of size " &lt;&lt; resultSize &lt;&lt; " bytes"; 
    std::string temp1(buffer, resultSize); 
    std::cout &lt;&lt; temp1; 
    //std::cout &lt;&lt; "\n  writing buffer of size " &lt;&lt; resultSize &lt;&lt; "bytes"; 
    bufferOut.putBuffer(resultSize, buffer); 
    if (resultSize &lt; bufLen || !bufferIn.isGood() || !bufferOut.isGood()) 
    { 
      bufferIn.close(); 
      bufferOut.close(); 
      break; 
    } 
  } 
  std::cout &lt;&lt; "\n\n"; 
</pre>} 
#endif 
</pre>
<script src="../JS/hideHandler.js"></script>
</body>
</html>