<!----------------------------------------------------------------------------
   ActionsAndRules.h.htm  -Published HTML File
   Published on : 2017-04-04.21:42:46
   Author:Karthik Palepally Muniyappa  
----------------------------------------------------------------------------->
<html>
<head>
<link rel="stylesheet" href="../CSS/style.css">
</head>
<body>
<h3>ActionsAndRules.h</h3>
<hr />
<div class="indent">
<h4>Dependencies:</h4>
<ul>
<li><a href="ActionsAndRules.cpp.htm">ActionsAndRules.cpp</a></li>
<li><a href="Logger.h.htm">Logger.h</a></li>
<li><a href="FileSystem.h.htm">FileSystem.h</a></li>
<li><a href="ScopeStack.h.htm">ScopeStack.h</a></li>
<li><a href="AbstrSynTree.h.htm">AbstrSynTree.h</a></li>
<li><a href="Tokenizer.h.htm">Tokenizer.h</a></li>
<li><a href="Tokenizer.h.htm">Tokenizer.h</a></li>
<li><a href="Parser.h.htm">Parser.h</a></li>
<li><a href="itokcollection.h.htm">itokcollection.h</a></li>
<li><a href="itokcollection.h.htm">itokcollection.h</a></li>
<li><a href="GrammarHelpers.h.htm">GrammarHelpers.h</a></li>
<li><a href="GrammarHelpers.cpp.htm">GrammarHelpers.cpp</a></li>
<li><a href="SemiExp.h.htm">SemiExp.h</a></li>
</ul>
</div>
<hr />
<pre>
#ifndef ACTIONSANDRULES_H 
#define ACTIONSANDRULES_H 
///////////////////////////////////////////////////////////////////// 
//  ActionsAndRules.h - declares new parsing rules and actions     // 
//  ver 3.3                                                        // 
//  Language:      Visual C++ 2008, SP1                            // 
//  Platform:      Dell Precision T7400, Vista Ultimate SP1        // 
//  Application:   Prototype for CSE687 Pr1, Sp09                  // 
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     // 
//                 (315) 443-3948, jfawcett@twcny.rr.com           // 
///////////////////////////////////////////////////////////////////// 
/* 
  Module Operations:  
  ================== 
  This module defines several action classes.  Its classes provide  
  specialized services needed for specific applications.  The modules 
  Parser, SemiExpression, and Tokenizer, are intended to be reusable 
  without change.  This module provides a place to put extensions of 
  these facilities and is not expected to be reusable.  
 
  Public Interface: 
  ================= 
  Toker t(someFile);              // create tokenizer instance 
  SemiExp se(&t);                 // create a SemiExp attached to tokenizer 
  Parser parser(se);              // now we have a parser 
  Rule1 r1;                       // create instance of a derived Rule class 
  Action1 a1;                     // create a derived action 
  r1.addAction(&a1);              // register action with the rule 
  parser.addRule(&r1);            // register rule with parser 
  while(se.getSemiExp())          // get semi-expression 
    parser.parse();               //   and parse it 
 
  Build Process: 
  ============== 
  Required files 
    - Parser.h, Parser.cpp, ScopeStack.h, ScopeStack.cpp, 
      ActionsAndRules.h, ActionsAndRules.cpp, ConfigureParser.cpp, 
      ItokCollection.h, SemiExpression.h, SemiExpression.cpp, tokenizer.h, tokenizer.cpp 
  Build commands (either one) 
    - devenv CodeAnalysis.sln 
    - cl /EHsc /DTEST_PARSER parser.cpp ActionsAndRules.cpp \ 
         semiexpression.cpp tokenizer.cpp /link setargv.obj 
 
  Maintenance History: 
  ==================== 
  ver 3.3 : 26 Feb 2017 
  - Fixed bug in public data analysis with changes to rule CppDeclaration 
    and its action HandleCppDeclaration. 
  - Fixed a minor bug in name collection for operators.  Won't be important 
    for dependency analysis. 
  ver 3.2 : 28 Aug 16 
  - fixed errors in many rules and actions based on lots of testing 
  - cleaned up text, removing comments and improving prologues 
  ver 3.1 : 23 Aug 16 
  - qualified input pointers in rules and actions as const 
  - cleaned up code by removing unreachables and commented code, and by simplifying  
  ver 3.0 : 06 Aug 16 
  - Added use of AbstrSynTree 
  - Added new rules and actions 
  - Renamed and modified most of the other actions and rules 
  ver 2.1 : 15 Feb 16 
  - small functional change to a few of the actions changes display strategy 
  - preface the (new) Toker and SemiExp with Scanner namespace 
  ver 2.0 : 01 Jun 11 
  - added processing on way to building strong code analyzer 
  ver 1.1 : 17 Jan 09 
  - changed to accept a pointer to interfaced ITokCollection instead 
    of a SemiExpression 
  ver 1.0 : 12 Jan 06 
  - first release 
 
  Planned Changes: 
  ================ 
  C++ lambda detection needs strengthening 
*/ 
// 
#include &lt;queue&gt; 
#include &lt;string&gt; 
#include &lt;sstream&gt; 
#include &lt;iomanip&gt; 
#include "Parser.h" 
#include "../GrammarHelpers/GrammarHelpers.h" 
#include "../SemiExp/itokcollection.h" 
#include "../ScopeStack/ScopeStack.h" 
#include "../Tokenizer/Tokenizer.h" 
#include "../SemiExp/SemiExp.h" 
#include "../AbstractSyntaxTree/AbstrSynTree.h" 
#include "../Logger/Logger.h" 
#include "../FileSystem/FileSystem.h" 
 
namespace CodeAnalysis 
{   
  /////////////////////////////////////////////////////////////////// 
  // Repository instance is used to share resources 
  // among all actions. 
 
  enum Language { C /* not implemented */, Cpp, CSharp }; 
 
  class Repository  // application specific 
  {<button onclick="myFunction(this)" id="button129">-</button><pre class="showElem" id="button129_pre"> 
  public: 
    using Rslt = Logging::StaticLogger&lt;0&gt;;  // use for application results 
    using Demo = Logging::StaticLogger&lt;1&gt;;  // use for demonstrations of processing 
    using Dbug = Logging::StaticLogger&lt;2&gt;;  // use for debug output 
    using Package = std::string; 
    using Path = std::string; 
 
  private: 
    Language language_ = Language::Cpp; 
    Path path_; 
    ScopeStack&lt;ASTNode*&gt; stack; 
    AbstrSynTree ast; 
    ASTNode* pGlobalScope; 
    Package package_; 
    Scanner::Toker* p_Toker; 
    Access currentAccess_ = Access::publ; 
    static Repository* instance; 
   
  public: 
     
    Repository(Scanner::Toker* pToker) : ast(stack) 
    {<button onclick="myFunction(this)" id="button130">-</button><pre class="showElem" id="button130_pre"> 
      p_Toker = pToker; 
      pGlobalScope = stack.top(); 
      instance = this; 
</pre>    } 
 
    ~Repository() 
    {<button onclick="myFunction(this)" id="button131">-</button><pre class="showElem" id="button131_pre"> 
      Dbug::write("\n  deleting repository"); 
</pre>    } 
 
    Language& language() { return language_; } 
 
    Package& package() { return package_; } 
 
    Path& currentPath() { return path_; } 
 
    Access& currentAccess() { return currentAccess_; } 
 
    static Repository* getInstance() { return instance; } 
 
    ScopeStack&lt;ASTNode*&gt;& scopeStack() { return stack; } 
 
    AbstrSynTree& AST() { return ast; } 
 
    ASTNode* getGlobalScope() { return pGlobalScope; } 
 
    Scanner::Toker* Toker() { return p_Toker; } 
 
    size_t lineCount() <button onclick="myFunction(this)" id="button141">-</button><pre class="showElem" id="button141_pre"> 
    {  
      return (size_t)(p_Toker-&gt;currentLineCount());  
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect beginning of scope 
 
  class BeginScope : public IRule 
  {<button onclick="myFunction(this)" id="button142">-</button><pre class="showElem" id="button142_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button143">-</button><pre class="showElem" id="button143_pre"> 
      GrammarHelper::showParseDemo("Test begin scope", *pTc); 
 
      // don't parse SemiExp with single semicolon token 
 
      if (pTc-&gt;length() == 1 && (*pTc)[0] == ";") 
        return IRule::Stop; 
 
      if (pTc-&gt;find("{") &lt; pTc-&gt;length()) 
      { 
        doActions(pTc); 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to handle scope stack at beginning of scope 
 
  class HandleBeginScope : public IAction 
  {<button onclick="myFunction(this)" id="button144">-</button><pre class="showElem" id="button144_pre"> 
    Repository* p_Repos; 
  public: 
    HandleBeginScope(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button145">-</button><pre class="showElem" id="button145_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button146">-</button><pre class="showElem" id="button146_pre"> 
      GrammarHelper::showParseDemo("handle begin scope", *pTc); 
      //if (p_Repos-&gt;scopeStack().size() == 0) 
      //  Repository::Demo::write("\n--- empty stack ---"); 
 
      ASTNode* pElem = new ASTNode; 
      pElem-&gt;type_ = "anonymous"; 
      pElem-&gt;name_ = "none"; 
      pElem-&gt;package_ = p_Repos-&gt;package(); 
      pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount(); 
      pElem-&gt;endLineCount_ = 1; 
      pElem-&gt;path_ = p_Repos-&gt;currentPath(); 
      /* 
       * make this ASTNode child of ASTNode on stack top 
       * then push onto stack 
       */ 
      p_Repos-&gt;AST().add(pElem); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect end of scope 
 
  class EndScope : public IRule 
  {<button onclick="myFunction(this)" id="button147">-</button><pre class="showElem" id="button147_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button148">-</button><pre class="showElem" id="button148_pre"> 
      GrammarHelper::showParseDemo("Test end scope", *pTc); 
 
      //std::string debug = pTc-&gt;show(); 
 
      if (pTc-&gt;find("}") &lt; pTc-&gt;length()) 
      { 
        doActions(pTc); 
        return IRule::Stop; 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to handle scope stack at end of scope 
 
  class HandleEndScope : public IAction 
  {<button onclick="myFunction(this)" id="button149">-</button><pre class="showElem" id="button149_pre"> 
    Repository* p_Repos; 
  public: 
    using Dbug = Logging::StaticLogger&lt;2&gt;; 
 
    HandleEndScope(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button150">-</button><pre class="showElem" id="button150_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button151">-</button><pre class="showElem" id="button151_pre"> 
      GrammarHelper::showParseDemo("Handle end scope", *pTc); 
 
      //if (p_Repos-&gt;scopeStack().size() == 0) 
      //{ 
      //  Repository::Demo::flush(); 
      //  Repository::Demo::write("\n--- empty stack ---"); 
      //} 
      //ASTNode* pDebug = p_Repos-&gt;scopeStack().top(); 
      //std::string debug1 = pDebug-&gt;name_; 
      //std::string debug2 = pDebug-&gt;type_; 
      //std::string debug3 = pDebug-&gt;package_; 
      //std::string debug = pElem-&gt;name_; 
 
      if (p_Repos-&gt;scopeStack().size() == 0) 
        return; 
 
      ASTNode* pElem = p_Repos-&gt;AST().pop(); 
 
      pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount(); 
      if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct") 
        (pElem-&gt;endLineCount_)++; 
 
      p_Repos-&gt;currentAccess() = Access::priv; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect access for C++ 
 
  class DetectAccessSpecifier : public IRule 
  {<button onclick="myFunction(this)" id="button152">-</button><pre class="showElem" id="button152_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button153">-</button><pre class="showElem" id="button153_pre"> 
      GrammarHelper::showParseDemo("Test access spec", *pTc); 
 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::Cpp) 
        return IRule::Continue; 
 
      size_t pos = pTc-&gt;find(":"); 
      if (0 &lt; pos && pos &lt; pTc-&gt;length()) 
      { 
        const std::string tok = (*pTc)[pos - 1]; 
        if (tok == "public" || tok == "protected" || tok == "private") 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to handle access specifier 
 
  class HandleAccessSpecifier : public IAction 
  {<button onclick="myFunction(this)" id="button154">-</button><pre class="showElem" id="button154_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleAccessSpecifier(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button155">-</button><pre class="showElem" id="button155_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button156">-</button><pre class="showElem" id="button156_pre"> 
      GrammarHelper::showParseDemo("Handle access spec: ", *pTc); 
 
      std::string tok = (*pTc)[pTc-&gt;length() - 2]; 
      Access& access = p_Repos-&gt;currentAccess(); 
      if (tok == "public") 
        access = Access::publ; 
      else if (tok == "protected") 
        access = Access::prot; 
      else 
        access = Access::priv; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect preprocessor statements 
 
  class PreprocStatement : public IRule 
  {<button onclick="myFunction(this)" id="button157">-</button><pre class="showElem" id="button157_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button158">-</button><pre class="showElem" id="button158_pre"> 
      GrammarHelper::showParseDemo("Test preproc statement: ", *pTc); 
 
      //std::string debug = pTc-&gt;show(); 
 
      if (pTc-&gt;find("#") &lt; pTc-&gt;length()) 
      { 
        doActions(pTc); 
        return IRule::Stop; 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add semiexp to scope stack top statements_ 
 
  class HandlePreprocStatement : public IAction 
  {<button onclick="myFunction(this)" id="button159">-</button><pre class="showElem" id="button159_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandlePreprocStatement(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button160">-</button><pre class="showElem" id="button160_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button161">-</button><pre class="showElem" id="button161_pre"> 
      GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc); 
 
      Scanner::ITokCollection* pClone = pTc-&gt;clone(); 
      ASTNode* pElem = p_Repos-&gt;scopeStack().top(); 
      pElem-&gt;statements_.push_back(pClone); 
 
      GrammarHelper::showParse("Preproc Stmt", *pTc); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect namespace statements 
 
  class NamespaceDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button162">-</button><pre class="showElem" id="button162_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button163">-</button><pre class="showElem" id="button163_pre"> 
      GrammarHelper::showParseDemo("Test namespace definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc[tc.length() - 1] == "{") 
      { 
        size_t len = tc.find("namespace"); 
        if (len &lt; tc.length()) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add namespace info to scope stack top 
 
  class HandleNamespaceDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button164">-</button><pre class="showElem" id="button164_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleNamespaceDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button165">-</button><pre class="showElem" id="button165_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button166">-</button><pre class="showElem" id="button166_pre"> 
      GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc); 
 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
 
      std::string name = (*pTc)[pTc-&gt;find("namespace") + 1]; 
      top-&gt;type_ = "namespace"; 
      top-&gt;name_ = name; 
      top-&gt;package_ = p_Repos-&gt;package(); 
 
      GrammarHelper::showParse("namespace def", *pTc); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect class statements 
 
  class ClassDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button167">-</button><pre class="showElem" id="button167_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button168">-</button><pre class="showElem" id="button168_pre"> 
      GrammarHelper::showParseDemo("Test class definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc[tc.length() - 1] == "{") 
      { 
        size_t len = tc.find("class"); 
        if (len &lt; tc.length()) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
        len = tc.find("interface"); 
        if (len &lt; tc.length()) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add class info to scope stack top 
 
  class HandleClassDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button169">-</button><pre class="showElem" id="button169_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleClassDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button170">-</button><pre class="showElem" id="button170_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button171">-</button><pre class="showElem" id="button171_pre"> 
      GrammarHelper::showParseDemo("Handle class definition: ", *pTc); 
 
      p_Repos-&gt;currentAccess() = Access::priv; 
 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
      size_t typeIndex = pTc-&gt;find("class"); 
      if (typeIndex &lt; pTc-&gt;length()) 
      { 
        size_t nameIndex = typeIndex + 1; 
        std::string name = (*pTc)[nameIndex]; 
        top-&gt;type_ = "class"; 
        top-&gt;name_ = name; 
        top-&gt;package_ = p_Repos-&gt;package(); 
        p_Repos-&gt;AST().typeMap()[name] = top; 
        GrammarHelper::showParse("class def", *pTc); 
      } 
      else  // C# 
      { 
        typeIndex = pTc-&gt;find("interface"); 
        size_t nameIndex = typeIndex + 1; 
        std::string name = (*pTc)[nameIndex]; 
        top-&gt;type_ = "interface"; 
        top-&gt;name_ = name; 
        top-&gt;package_ = p_Repos-&gt;package(); 
        p_Repos-&gt;AST().typeMap()[name] = top; 
        GrammarHelper::showParse("interface def", *pTc); 
      } 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect struct statements 
 
  class StructDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button172">-</button><pre class="showElem" id="button172_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button173">-</button><pre class="showElem" id="button173_pre"> 
      GrammarHelper::showParseDemo("Test struct definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc[tc.length() - 1] == "{") 
      { 
        size_t len = tc.find("struct"); 
        if (len &lt; tc.length()) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add struct info to scope stack top 
 
  class HandleStructDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button174">-</button><pre class="showElem" id="button174_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleStructDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button175">-</button><pre class="showElem" id="button175_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button176">-</button><pre class="showElem" id="button176_pre"> 
      GrammarHelper::showParseDemo("Handle struct definition: ", *pTc); 
 
      p_Repos-&gt;currentAccess() = Access::publ; 
 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
 
      std::string name = (*pTc)[pTc-&gt;find("struct") + 1]; 
      top-&gt;type_ = "struct"; 
      top-&gt;name_ = name; 
      top-&gt;package_ = p_Repos-&gt;package(); 
      p_Repos-&gt;AST().typeMap()[name] = top; 
 
      GrammarHelper::showParse("struct def", *pTc); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C++ function definitions 
 
  class CppFunctionDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button177">-</button><pre class="showElem" id="button177_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button178">-</button><pre class="showElem" id="button178_pre"> 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::Cpp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      std::string debug = pTc-&gt;show(); 
 
      if (tc[tc.length() - 1] == "{") 
      { 
        if (GrammarHelper::isFunction(*pTc)) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add function info to scope stack top 
 
  class HandleCppFunctionDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button179">-</button><pre class="showElem" id="button179_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleCppFunctionDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button180">-</button><pre class="showElem" id="button180_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button181">-</button><pre class="showElem" id="button181_pre"> 
      GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc); 
 
      //std::string debug = pTc-&gt;show(); 
 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
 
      size_t nameIndex = pTc-&gt;find("(") - 1; 
      std::string name = (*pTc)[nameIndex]; 
 
      // is function a destructor? 
 
      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~") 
      { 
        --nameIndex; 
        name = "~" + name; 
      } 
 
      top-&gt;type_ = "function"; 
      top-&gt;name_ = name; 
      top-&gt;package_ = p_Repos-&gt;package(); 
 
      GrammarHelper::showParse("function def", *pTc); 
 
      // is function an operator? 
 
      size_t operIndex = pTc-&gt;find("operator"); 
      if (operIndex &lt; pTc-&gt;length()) 
      { 
        name = "operator" + (*pTc)[operIndex + 1];// +(*pTc)[operIndex + 2]; 
        if ((*pTc)[operIndex + 2] != "(") 
          name += (*pTc)[operIndex + 2]; 
        top-&gt;name_ = name; 
        nameIndex = operIndex; 
      } 
      // is function a member of a class or struct? 
 
      if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::") 
      { 
        //----&lt; start find class name &gt;-------------------- 
 
        std::string className = (*pTc)[nameIndex - 2]; 
 
        // is class a template? 
 
        if (className == "&gt;") 
        { 
          size_t startParam = GrammarHelper::findLast(*pTc, "&lt;"); 
          if (0 &lt; startParam && startParam &lt; pTc-&gt;length()) 
            className = (*pTc)[startParam - 1]; 
        } 
        //----&lt; end find class name &gt;---------------------- 
        /* 
        * - this function's ASTNode is at stack top 
        * - find ASTNode of function's class 
        * - unlink function ASTNode from stack top predecessor 
        * - relink function ASTNode to it's class ASTNode 
        * - leave function ASTNode on stack top as it may have child nodes 
        */ 
        ASTNode* pClassNode = p_Repos-&gt;AST().find(className); 
        if (pClassNode == nullptr) 
          return; 
        ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top(); 
        ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop(); 
        pParentNode-&gt;children_.pop_back();           // unlink function 
        pClassNode-&gt;children_.push_back(pFunctNode); // relink function 
        return; 
      } 
      // is this a lambda? 
 
      std::string packageName = p_Repos-&gt;package(); 
      std::string ext = FileSystem::Path::getExt(packageName); 
 
      size_t posOpenBracket = pTc-&gt;find("["); 
      size_t posCloseBracket = pTc-&gt;find("]"); 
      size_t posBrace = pTc-&gt;find("{"); 
      if (posOpenBracket &lt; posCloseBracket && posBrace == (posCloseBracket + 1) && posBrace &lt; pTc-&gt;length()) 
      { 
        std::string name; 
        for (size_t i = posOpenBracket; i &lt; posBrace; ++i) 
          name += (*pTc)[i]; 
        top-&gt;name_ = name; 
        top-&gt;type_ = "lambda"; 
      } 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C# function definitions 
 
  class CSharpFunctionDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button182">-</button><pre class="showElem" id="button182_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button183">-</button><pre class="showElem" id="button183_pre"> 
      //std::string debug = pTc-&gt;show(); 
 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::CSharp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C# function definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc[tc.length() - 1] == "{") 
      { 
        Scanner::SemiExp se; 
        for (size_t i = 0; i &lt; tc.length(); ++i) 
          se.push_back(tc[i]); 
 
        if (GrammarHelper::isFunction(se)) 
        { 
          std::string debug = se.show(); 
          doActions(&se); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add function info to scope stack top 
 
  class HandleCSharpFunctionDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button184">-</button><pre class="showElem" id="button184_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleCSharpFunctionDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button185">-</button><pre class="showElem" id="button185_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button186">-</button><pre class="showElem" id="button186_pre"> 
      GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc); 
 
      std::string debug = pTc-&gt;show(); 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
 
      size_t nameIndex = pTc-&gt;find("(") - 1; 
      std::string name = (*pTc)[nameIndex]; 
 
      // is function a destructor? 
 
      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~") 
      { 
        --nameIndex; 
        name = "~" + name; 
      } 
 
      top-&gt;type_ = "function"; 
      top-&gt;name_ = name; 
      top-&gt;package_ = p_Repos-&gt;package(); 
 
      GrammarHelper::showParse("function def", *pTc); 
 
      // is function an operator? 
 
      size_t operIndex = pTc-&gt;find("operator"); 
      if (operIndex &lt; pTc-&gt;length()) 
      { 
        name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2]; 
        top-&gt;name_ = name; 
        nameIndex = operIndex; 
      } 
 
      // is lambda? 
 
      size_t posParen = pTc-&gt;find("("); 
      size_t posBrace = pTc-&gt;find("{"); 
      size_t posEqual = pTc-&gt;find("="); 
      if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;length()) 
      { 
        if (posEqual &lt; pTc-&gt;length() - 1 && (*pTc)[posEqual + 1] == "&gt;") 
        { 
          std::string name; 
          for (size_t i = posParen; i &lt;= posBrace; ++i) 
            name += (*pTc)[i]; 
          top-&gt;name_ = name; 
          top-&gt;type_ = "lambda"; 
        } 
      } 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect control definitions 
 
  class ControlDefinition : public IRule 
  {<button onclick="myFunction(this)" id="button187">-</button><pre class="showElem" id="button187_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button188">-</button><pre class="showElem" id="button188_pre"> 
      GrammarHelper::showParseDemo("Test control definition: ", *pTc); 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc[tc.length() - 1] == "{") 
      { 
        size_t len = tc.find("("); 
        if (len &lt; tc.length() && GrammarHelper::isControlKeyWord(tc[len - 1])) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
        else if (tc.length() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.length() - 2])) 
        { 
          // shouldn't need this scope since all semiExps have been trimmed 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add control info to scope stack top 
 
  class HandleControlDefinition : public IAction 
  {<button onclick="myFunction(this)" id="button189">-</button><pre class="showElem" id="button189_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleControlDefinition(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button190">-</button><pre class="showElem" id="button190_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button191">-</button><pre class="showElem" id="button191_pre"> 
      GrammarHelper::showParseDemo("Handle control definition: ", *pTc); 
 
      ASTNode* top = p_Repos-&gt;scopeStack().top(); 
 
      size_t nameIndex = pTc-&gt;find("(") - 1;  // if, for, while, switch, catch 
      if (nameIndex == pTc-&gt;length() - 1)     // do, try - they don't have parens 
        nameIndex = pTc-&gt;length() - 2; 
      std::string name = (*pTc)[nameIndex]; 
      top-&gt;type_ = "control"; 
      top-&gt;name_ = name; 
 
      GrammarHelper::showParse("control def", *pTc); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to send semi-expression that starts a function def 
  // to console 
 
  class PrintFunction : public IAction 
  {<button onclick="myFunction(this)" id="button192">-</button><pre class="showElem" id="button192_pre"> 
    Repository* p_Repos; 
  public: 
    using Rslt = Logging::StaticLogger&lt;0&gt;; 
 
    PrintFunction(Repository* pRepos) 
    {<button onclick="myFunction(this)" id="button193">-</button><pre class="showElem" id="button193_pre"> 
      p_Repos = pRepos; 
</pre>    } 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button194">-</button><pre class="showElem" id="button194_pre"> 
      std::ostringstream out; 
      out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str(); 
      Rslt::write(out.str()); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to send signature of a function def to console 
 
  class PrettyPrintFunction : public IAction 
  {<button onclick="myFunction(this)" id="button195">-</button><pre class="showElem" id="button195_pre"> 
    Repository* p_Repos; 
  public: 
    using Rslt = Logging::StaticLogger&lt;0&gt;; 
 
    PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button197">-</button><pre class="showElem" id="button197_pre"> 
      size_t len = pTc-&gt;find(")"); 
 
      std::ostringstream out; 
      out &lt;&lt; "\n\n  Pretty Stmt:    "; 
      for (size_t i = 0; i &lt; len + 1; ++i) 
        out &lt;&lt; (*pTc)[i] &lt;&lt; " "; 
      out &lt;&lt; "\n"; 
      Rslt::write(out.str()); 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C++ Declaration 
  /* 
  *  - Declaration ends in semicolon 
  *  - has type, name, modifiers & initializers 
  *  So: 
  *  - strip off modifiers and initializers 
  *  - if you have two things left it's a declar, else executable 
  */ 
  class CppDeclaration : public IRule 
  {<button onclick="myFunction(this)" id="button198">-</button><pre class="showElem" id="button198_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button199">-</button><pre class="showElem" id="button199_pre"> 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::Cpp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc); 
      std::string debug3 = pTc-&gt;show(); 
 
      Scanner::SemiExp tc; 
      tc.clone(*pTc); 
 
      // begin added 2/26/2017 
 
      Access access = pRepo-&gt;currentAccess(); 
      bool isPublic = false; 
      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_; 
 
      if (pTc-&gt;find("private") &lt; pTc-&gt;length()) 
      { 
        isPublic = false; 
        pRepo-&gt;currentAccess() = Access::priv; 
      } 
 
      if (pTc-&gt;find("protected") &lt; pTc-&gt;length()) 
      { 
        isPublic = false; 
        pRepo-&gt;currentAccess() = Access::prot; 
      } 
 
      if (pTc-&gt;find("public") &lt; pTc-&gt;length() && parentType != "function") 
      { 
        isPublic = true; 
        pRepo-&gt;currentAccess() = Access::publ; 
      } 
 
      // end added 2/26/2017 
 
      if (tc.length() &gt; 0 && tc[0] == "using") 
      { 
        doActions(pTc); 
        return IRule::Stop; 
      } 
 
      std::string debug = tc.show(); 
       
      if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2) 
      { 
        std::string nextToLast = tc[tc.length() - 2]; 
        if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const") 
        { 
          { 
            // function declaration 
            doActions(pTc); 
            return IRule::Stop; 
          } 
        } 
        std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_; 
         
        if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType)) 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
 
        if (parentType != "function") 
        { 
          // can't be executable so must be declaration 
 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add declaration info to scope stack top 
 
  class HandleCppDeclaration : public IAction 
  {<button onclick="myFunction(this)" id="button200">-</button><pre class="showElem" id="button200_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button202">-</button><pre class="showElem" id="button202_pre"> 
      GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc); 
 
      // save declaration info in ASTNode 
 
      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top(); 
      DeclarationNode declNode; 
      declNode.access_ = p_Repos-&gt;currentAccess(); 
      declNode.pTc = pTc-&gt;clone(); 
      declNode.package_ = p_Repos-&gt;package(); 
      declNode.line_ = p_Repos-&gt;lineCount(); 
 
      Scanner::SemiExp se; 
      se.clone(*pTc); 
      GrammarHelper::removeComments(se); 
 
      if (se[0] == "using") 
      { 
        declNode.declType_ = DeclType::usingDecl; 
        pCurrNode-&gt;decl_.push_back(declNode); 
 
        GrammarHelper::showParse("using declar", *pTc); 
        return; 
      } 
 
      if (GrammarHelper::isFunctionDeclaration(se,"parentNotFunction")) 
      { 
        return; 
      } 
 
      if (GrammarHelper::isDataDeclaration(se)) 
      { 
        declNode.declType_ = DeclType::dataDecl; 
        pCurrNode-&gt;decl_.push_back(declNode); 
        GrammarHelper::showParse("data declar", *pTc); 
      } 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C# Declaration 
  /* 
  *  - Declaration ends in semicolon 
  *  - has type, name, modifiers & initializers 
  *  So: 
  *  - strip of modifiers and initializers 
  *  - if you have two things left it's a declar, else executable 
  */ 
  class CSharpDeclaration : public IRule 
  {<button onclick="myFunction(this)" id="button203">-</button><pre class="showElem" id="button203_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button204">-</button><pre class="showElem" id="button204_pre"> 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::CSharp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C# declaration: ", *pTc); 
 
      std::string debug = pTc-&gt;show(); 
       
      Access access = pRepo-&gt;currentAccess(); 
      bool isPublic = false; 
      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_; 
 
      if (pTc-&gt;find("public") &lt; pTc-&gt;length() && parentType != "function") 
      { 
        isPublic = true; 
        pRepo-&gt;currentAccess() = Access::publ; 
      } 
 
      const Scanner::ITokCollection& tc = *pTc; 
      if (tc.length() &gt; 0 && tc[0] == "using") 
      { 
        doActions(pTc); 
        pRepo-&gt;currentAccess() = access; 
        return IRule::Stop; 
      } 
 
      Scanner::SemiExp se; 
      se.clone(*pTc); 
 
      if (GrammarHelper::isDataDeclaration(se)) 
      { 
        doActions(pTc); 
        pRepo-&gt;currentAccess() = access; 
        return IRule::Stop; 
      } 
 
      if (GrammarHelper::isFunctionDeclaration(se, parentType)) 
      { 
        doActions(pTc); 
        pRepo-&gt;currentAccess() = access; 
        return IRule::Stop; 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to add declaration info to scope stack top 
 
  class HandleCSharpDeclaration : public IAction 
  {<button onclick="myFunction(this)" id="button205">-</button><pre class="showElem" id="button205_pre"> 
    Repository* p_Repos; 
 
  public: 
    HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button207">-</button><pre class="showElem" id="button207_pre"> 
      GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc); 
 
      // store declaration info in ASTNode 
 
      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top(); 
      DeclarationNode declNode; 
      declNode.access_ = p_Repos-&gt;currentAccess(); 
      declNode.pTc = pTc-&gt;clone(); 
      declNode.package_ = p_Repos-&gt;package(); 
      declNode.line_ = p_Repos-&gt;lineCount(); 
 
      Scanner::SemiExp se; 
      se.clone(*pTc); 
      GrammarHelper::removeComments(se); 
 
      if (se[0] == "using") 
      { 
        declNode.declType_ = DeclType::usingDecl; 
        pCurrNode-&gt;decl_.push_back(declNode); 
 
        GrammarHelper::showParse("using declar", *pTc); 
        return; 
      } 
      //std::string debug = se.show(); 
 
      std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_; 
 
      if (GrammarHelper::isFunctionDeclaration(se, parentType)) 
      { 
        std::string debug = se.show(); 
        Access adebug = declNode.access_; 
        declNode.declType_ = DeclType::functionDecl; 
        pCurrNode-&gt;decl_.push_back(declNode); 
        GrammarHelper::showParse("function declar", *pTc); 
      } 
      else 
      { 
        std::string debug = se.show(); 
        Access adebug = declNode.access_; 
        declNode.declType_ = DeclType::dataDecl; 
        pCurrNode-&gt;decl_.push_back(declNode); 
        GrammarHelper::showParse("data declar", *pTc); 
      } 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C++ Executable 
 
  class CppExecutable : public IRule 
  {<button onclick="myFunction(this)" id="button208">-</button><pre class="showElem" id="button208_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button209">-</button><pre class="showElem" id="button209_pre"> 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::Cpp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C++ executable: ", *pTc); 
 
      Scanner::SemiExp tc; 
      tc.clone(*pTc); 
 
      if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2) 
      { 
        GrammarHelper::removeFunctionArgs(tc); 
        GrammarHelper::condenseTemplateTypes(tc); 
 
        // remove modifiers, comments, newlines, returns, and initializers 
 
        Scanner::SemiExp se; 
        for (size_t i = 0; i &lt; tc.length(); ++i) 
        { 
          if (GrammarHelper::isQualifierKeyWord(tc[i])) 
            continue; 
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return") 
            continue; 
          if (tc[i] == "=" || tc[i] == ";") 
          { 
            se.push_back(";"); 
            break; 
          } 
          else 
            se.push_back(tc[i]); 
        } 
        if (se.length() != 3)  // not a declaration 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
 
  /////////////////////////////////////////////////////////////// 
  // action to display C++ executable info 
 
  class HandleCppExecutable : public IAction 
  {<button onclick="myFunction(this)" id="button210">-</button><pre class="showElem" id="button210_pre"> 
    Repository* p_Repo; 
 
  public: 
    HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button212">-</button><pre class="showElem" id="button212_pre"> 
      GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc); 
 
      GrammarHelper::showParse("executable", *pTc); 
</pre>    } 
</pre>  }; 
  /////////////////////////////////////////////////////////////// 
  // rule to detect C# Executable 
 
  class CSharpExecutable : public IRule 
  {<button onclick="myFunction(this)" id="button213">-</button><pre class="showElem" id="button213_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button214">-</button><pre class="showElem" id="button214_pre"> 
      Repository* pRepo = Repository::getInstance(); 
      if (pRepo-&gt;language() != Language::CSharp) 
        return IRule::Continue; 
 
      GrammarHelper::showParseDemo("Test C# executable: ", *pTc); 
 
      const Scanner::ITokCollection& in = *pTc; 
      Scanner::SemiExp tc; 
      for (size_t i = 0; i &lt; in.length(); ++i) 
        tc.push_back(in[i]); 
 
      if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2) 
      { 
        GrammarHelper::removeFunctionArgs(tc); 
        GrammarHelper::condenseTemplateTypes(tc); 
 
        // remove modifiers, comments, newlines, returns, and initializers 
 
        Scanner::SemiExp se; 
        for (size_t i = 0; i &lt; tc.length(); ++i) 
        { 
          if (GrammarHelper::isQualifierKeyWord(tc[i])) 
            continue; 
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return") 
            continue; 
          if (tc[i] == "=" || tc[i] == ";") 
          { 
            se.push_back(";"); 
            break; 
          } 
          else 
            se.push_back(tc[i]); 
        } 
        if (se.length() != 3)  // not a declaration 
        { 
          doActions(pTc); 
          return IRule::Stop; 
        } 
      } 
      return IRule::Continue; 
</pre>    } 
</pre>  }; 
  /////////////////////////////////////////////////////////////// 
  // action to display C# executable info 
 
  class HandleCSharpExecutable : public IAction 
  {<button onclick="myFunction(this)" id="button215">-</button><pre class="showElem" id="button215_pre"> 
    Repository* p_Repo; 
 
  public: 
    HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button217">-</button><pre class="showElem" id="button217_pre"> 
      GrammarHelper::showParseDemo("Handle C# executable: ", *pTc); 
 
      Scanner::SemiExp se; 
      se.clone(*pTc); 
      GrammarHelper::removeComments(se); 
 
      GrammarHelper::showParse("executable", se); 
</pre>    } 
</pre>  }; 
  /////////////////////////////////////////////////////////////// 
  // default rule 
  // - this is here to catch any SemiExp that didn't parse 
  // - We don't have rule for enums, so they are caugth here 
 
  class Default : public IRule 
  {<button onclick="myFunction(this)" id="button218">-</button><pre class="showElem" id="button218_pre"> 
  public: 
    bool doTest(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button219">-</button><pre class="showElem" id="button219_pre"> 
      GrammarHelper::showParseDemo("Test default: ", *pTc); 
 
      doActions(pTc);  // catches everything 
      return IRule::Stop; 
</pre>    } 
</pre>  }; 
  /////////////////////////////////////////////////////////////// 
  // action to display default info 
 
  class HandleDefault : public IAction 
  {<button onclick="myFunction(this)" id="button220">-</button><pre class="showElem" id="button220_pre"> 
    Repository* p_Repo; 
 
  public: 
    HandleDefault(Repository* pRepo) : p_Repo(pRepo) {} 
 
    void doAction(const Scanner::ITokCollection* pTc) override 
    {<button onclick="myFunction(this)" id="button222">-</button><pre class="showElem" id="button222_pre"> 
      GrammarHelper::showParseDemo("Handle default: ", *pTc); 
      GrammarHelper::showParse("default: ", *pTc); 
	  ASTNode* top = p_Repo-&gt;scopeStack().top(); 
	  std::string a = pTc-&gt;show(); 
	  size_t i = pTc-&gt;find("enum"); 
	  if (i == 0 && top-&gt;name_ == "none" && top-&gt;type_ == "anonymous") 
	  { 
		  i = pTc-&gt;find("enum"); 
		  i++; 
		  std::string n = (*pTc)[i]; 
		  top-&gt;type_ = "enum"; 
		  top-&gt;name_ = n; 
	  } 
</pre>    } 
</pre>  }; 
} 
#endif 
</pre>
<script src="../JS/hideHandler.js"></script>
</body>
</html>